# 3. Массив размером 2m + 1, где m — натуральное число, заполнен случайным образом. Найдите в массиве медиану.
# Медианой называется элемент ряда, делящий его на две равные части: в одной находятся элементы, которые
# не меньше медианы, в другой — не больше медианы.
# Примечание: задачу можно решить без сортировки исходного массива. Но если это слишком сложно, используйте метод
# сортировки, который не рассматривался на уроках (сортировка слиянием также недопустима).

import random as rnd

half = 5                                                    # Алгоритм в общем случае работает только для нечётного
arr = [rnd.randint(1, 25) for _ in range(half * 2 + 1)]     # число элементов в массиве: 1 из них обязательно будет
rnd.shuffle(arr)                                            # медианой (для чётного числа по-другому)
#arr = [5, 5, 5, 1, 5, 5, 1, 5, 5, 7, 5]

print(f'\nЭлементы исходного массива ({half * 2 + 1} шт.): {arr}')

m_lt = []           # элементы, меньшие медианы
m_gt = []           # элементы, большие медианы
m_eq = []           # элементы, равные медиане
passed = []         # элементы, уже проверенные на медианность (чтобы не повторяться)

for std in arr:                 # проверяем на медианность каждый элемент массива - какой-то обязательно подойдёт!
    if passed.count(std) > 0:   # элемент повторяется, он уже проверялся на медианность
        continue

    for el in arr:              # обходим весь массив для проверки выше выбранного элемента std на медианность
        if el < std:
            m_lt.append(el)     # элементы меньше медианы
        elif el > std:
            m_gt.append(el)     # элементы больше медианы
        else:
            m_eq.append(el)     # сюда как минимум попадёт проверяемый элемент std (также равные ему, если они есть)

    len_lt = len(m_lt)          # внутренний цикл пройден, массивы сформированы
    len_gt = len(m_gt)          # дальше будем длины печатать, поэтому вычислим их один раз здесь
    len_eq = len(m_eq)

    # критерий медианности: сумма модулей разности длины части массива до и после медианы и половины массива
    # без медиального элемента должна быть меньше или равной числу элементов, равных медиане

    if abs(len_lt - half) + abs(len_gt - half) <= len_eq - 1:       # за исключением медианного элемента
        break                                                       # медиана найдена и равна m_eq[0] - он же std

    m_eq.clear()                # очищаем списки "больше", "меньше", "равно"
    m_lt.clear()                # для проверки на медианность следующего элемента массива,
    m_gt.clear()                # если std не является медианой
    passed.append(std)          # добавляем проверяемый элемент в список уже проверенных на медианность

print(f'\nНайдено без сортировки: медиана {m_eq[0]}, элементы меньше {m_eq[0]} ({len_lt} шт.) {m_lt},'
      f' элементы больше {m_eq[0]} ({len_gt} шт.) {m_gt}', end='')
if len_eq > 1:
    print(f', элементы равные {m_eq[0]} (без учёта медианы) - {len_eq - 1} шт.', end='')

print("\n\nФакультативно - проверено сортировкой: ", end='')
arr.sort()  # условие задачи выполнено, способ сортировки не критичен: главное, чтобы медианы сошлись
print(f'медиана {arr[half]}, отсортированный исходный массив: {arr}')


